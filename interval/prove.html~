<html><head><title>prove Documentation</title></head>
<body><h1>
<a name="topofdoc"><img src="diag2min.gif">prove</a></h1>
<dl>
<dd>
	Given a list of functions, prove that at least one is negative
	at every point of a given <a href="domain.html">domain</a>.
 

</dl>
<hr><p></p>
<p><strong>[ 
<a href="kepler.html">kepler</a> | 
<a href="recurse.h">Source</a> | 
<a href="/keyweb.html">Keywords</a> | 
<a href="#aag">Summary</a> | <a href="#parents">Ancestors</a> | <a href="#flat">All Members</a> | <a href="#children">Descendants</a>  ]</strong><p>
<h2><a name="quickind">Quick Index</a></h2>
<dl>
<dd><a href="#OVERVIEW_TEXT">OVERVIEW TEXT</a>
<dd><a href="#AUTHOR">AUTHOR</a>
</dl>
<a name="aag"><hr><p></p></a><h2>Class Summary</h2>
class prove <br>
 {
<br>
<br><i><b>public</b></i>:
<dl>
<dd><strong>static</strong> int <a href="prove.html#int_recursiveVerifier(int_depth,_const_domain&amp_x,const_domain&amp_z,_const_domain&amp_x0,const_domain&amp_z0,_const_taylorFunction*_I[],_int_count,const_cellOption&amp_options)$">recursiveVerifier</a>(int depth, const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z, const <a href="domain.html">domain</a>&amp x0,const <a href="domain.html">domain</a>&amp z0, const <a href="taylorFunction.html">taylorFunction</a>* I[], int count,const <a href="cellOption.html">cellOption</a>&amp options);
<dd><strong>static</strong> void <a href="prove.html#void_recursiveVerifierQ(int_depth,_const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,const_domain&amp_zB,_const_taylorFunction*_IA[],const_taylorFunction*_IB[],int_Nineq,_const_cellOption&amp_options)$">recursiveVerifierQ</a>(int depth, const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB, const <a href="domain.html">domain</a>&amp zA,const <a href="domain.html">domain</a>&amp zB, const <a href="taylorFunction.html">taylorFunction</a>* IA[],const <a href="taylorFunction.html">taylorFunction</a>* IB[],int Nineq, const <a href="cellOption.html">cellOption</a>&amp options);
<dd><strong>static</strong> int <a href="prove.html#int_generic(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_F)$">generic</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp F);
<dd><strong>static</strong> int <a href="prove.html#int_qrtet(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">qrtet</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_qrtetReduce_(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">qrtetReduce</a> (const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_flat(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flat</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_flatVc(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flatVc</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_upright(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">upright</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_octa(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">octa</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_octaWithoutEta(const_domain&amp_x,const_domain&amp_z,_const_taylorFunction&amp_FlessScore)$">octaWithoutEta</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z, const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_quadcluster(const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,_const_domain&amp_zB,_const_taylorFunction&amp_fA,_const_taylorFunction&amp_fB)$">quadcluster</a>(const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB, const <a href="domain.html">domain</a>&amp zA, const <a href="domain.html">domain</a>&amp zB, const <a href="taylorFunction.html">taylorFunction</a>&amp fA, const <a href="taylorFunction.html">taylorFunction</a>&amp fB);
</dl>
<i><b>protected</b></i>:
<dl>
</dl>
}; // prove <p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>prove</i><p>
<a name="OVERVIEW_TEXT"><hr><p></p></a><h3>OVERVIEW TEXT</h3>
	This class gathers together a number of routines that
	take a <a href="taylorFunction.html">taylorFunction</a> (or more generally a list of taylorFunctions F)
	and proves that at least one of the functions F is negative
	on the given <a href="domain.html">domain</a>.
<p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>prove</i><p>
<a name="AUTHOR"><hr><p></p></a><h3>AUTHOR</h3>
    Thomas C. Hales
<p>Back to the <a href="#topofdoc">top</a> of  <i>prove</i><p>
<a name="int_recursiveVerifier(int_depth,_const_domain&amp_x,const_domain&amp_z,_const_domain&amp_x0,const_domain&amp_z0,_const_taylorFunction*_I[],_int_count,const_cellOption&amp_options)$"><hr><p></p><h3>int recursiveVerifier(int depth, const domain&amp x,const domain&amp z, const domain&amp x0,const domain&amp z0, const taylorFunction* I[], int count,const cellOption&amp options);</h3></a>
	   recursiveVerifier is the main inequality verification
	   procedure for simplices.  
	   It starts with a list of taylorFunctions I[],
	   and attempts to prove that at every point of the <a href="domain.html">domain</a>
	   x--z, at least one of the functions is negative.
	   Start with depth=0.  Each step of the recursion will
	   increase the depth by 1.
	   Start with x=x0, z=z0.  As the <a href="domain.html">domain</a> is subdivided,
	   x will increase and z will decrease.  x0, z0 remain fixed,
	   unless there is dimension reduction.
<p>
<p><pre>
static int <a href="#int_recursiveVerifier(int_depth,_const_domain&amp_x,const_domain&amp_z,_const_domain&amp_x0,const_domain&amp_z0,_const_taylorFunction*_I[],_int_count,const_cellOption&amp_options)$">recursiveVerifier</a>(int depth,
	const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,     /// current cell
	const <a href="domain.html">domain</a>&amp x0,const <a href="domain.html">domain</a>&amp z0,   // boundary
	const <a href="taylorFunction.html">taylorFunction</a>* I[],
	int count,const <a href="cellOption.html">cellOption</a>&amp options);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="void_recursiveVerifierQ(int_depth,_const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,const_domain&amp_zB,_const_taylorFunction*_IA[],const_taylorFunction*_IB[],int_Nineq,_const_cellOption&amp_options)$"><hr><p></p><h3>void recursiveVerifierQ(int depth, const domain&amp xA,const domain&amp xB, const domain&amp zA,const domain&amp zB, const taylorFunction* IA[],const taylorFunction* IB[],int Nineq, const cellOption&amp options);</h3></a>
	   recursiveVerifierQ is the main inequality verification
	   procedure for quad clusters.
	   Each quad cluster is divided into two simplices A,B along
	   the shortest diagonal.  A list of taylorFunctions is
	   given IA, IB for the two simplices.  The recursiveVerifierQ
	   procedure attempts to show that at every point in the <a href="domain.html">domain</a>
	   xA--zA (on A), xB--zB (on B), there is an index for which
	   the sum of the values of IA[index] on A and IB[index] on B
	   is negative.  IA[index] or IB[index] is allowed to be positive
	   as long as the sum is negative.  Dimension reduction is
	   always used in recursiveVerifierQ.  Otherwise the dimensions
	   are too great to be handled by computer.  This means that
	   if unreducible taylorFunctions are used, the
	   results are unreliable.  
<p>
	   The depth starts out at 0.
<p>
<p><pre>
static void <a href="#void_recursiveVerifierQ(int_depth,_const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,const_domain&amp_zB,_const_taylorFunction*_IA[],const_taylorFunction*_IB[],int_Nineq,_const_cellOption&amp_options)$">recursiveVerifierQ</a>(int depth, 
	const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB,
	const <a href="domain.html">domain</a>&amp zA,const <a href="domain.html">domain</a>&amp zB,
	const <a href="taylorFunction.html">taylorFunction</a>* IA[],const <a href="taylorFunction.html">taylorFunction</a>* IB[],int Nineq,
	const <a href="cellOption.html">cellOption</a>&amp options);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_generic(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_F)$"><hr><p></p><h3>int generic(const domain&amp x,const domain&amp z,const taylorFunction&amp F);</h3></a>
	   Prove that F<0 on the <a href="domain.html">domain</a> x--z.  This function calls
	   recursiveVerifier.
<p>
<p><pre>
static int <a href="#int_generic(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_F)$">generic</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp F);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_qrtet(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int qrtet(const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
	   Prove that sigma+FlessScore <0 on the the domain x--z.
	   Two cases are considered according to whether the score
	   is compression or the analytic voronoi function.
	   qrtet calls recursiveVerifier twice.
<p>
<p><pre>
static int <a href="#int_qrtet(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">qrtet</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_qrtetReduce_(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int qrtetReduce (const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
	   Prove that sigma+FlessScore <0 on the the domain x--z, using
	   dimension reduction.
	   Two cases are considered according to whether the score
	   is compression or the analytic voronoi function.
	   It is assumed that FlessScore is reducible.  The procedure
	   keeps track of when the score sigma is reducible and acts
	   accordingly.
	   qrtetReduce calls recursiveVerifier twice.
<p>
<p><pre>
static int qrtetReduce
	(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_flat(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int flat(const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
<p>
<p><pre>
static int <a href="#int_flat(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flat</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_flatVc(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int flatVc(const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
<p>
<p><pre>
static int <a href="#int_flatVc(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flatVc</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_upright(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int upright(const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
	    This uses gamma or octavor depending on the context.
	    This verification function is suitable for quad clusters.
<p>
<p><pre>
static int <a href="#int_upright(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">upright</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_octa(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int octa(const domain&amp x,const domain&amp z,const taylorFunction&amp FlessScore);</h3></a>
<p>
<p><pre>
static int <a href="#int_octa(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">octa</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_octaWithoutEta(const_domain&amp_x,const_domain&amp_z,_const_taylorFunction&amp_FlessScore)$"><hr><p></p><h3>int octaWithoutEta(const domain&amp x,const domain&amp z, const taylorFunction&amp FlessScore);</h3></a>
<p>
<p><pre>
static int <a href="#int_octaWithoutEta(const_domain&amp_x,const_domain&amp_z,_const_taylorFunction&amp_FlessScore)$">octaWithoutEta</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,
		const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="int_quadcluster(const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,_const_domain&amp_zB,_const_taylorFunction&amp_fA,_const_taylorFunction&amp_fB)$"><hr><p></p><h3>int quadcluster(const domain&amp xA,const domain&amp xB, const domain&amp zA, const domain&amp zB, const taylorFunction&amp fA, const taylorFunction&amp fB);</h3></a>
<p>
<p><pre>
static int <a href="#int_quadcluster(const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,_const_domain&amp_zB,_const_taylorFunction&amp_fA,_const_taylorFunction&amp_fB)$">quadcluster</a>(const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB,
		const <a href="domain.html">domain</a>&amp zA, const <a href="domain.html">domain</a>&amp zB, 
		const <a href="taylorFunction.html">taylorFunction</a>&amp fA, const <a href="taylorFunction.html">taylorFunction</a>&amp fB);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> prove </i> <p>
<a name="flat"><hr><p></p></a>
<h2>All Members</h2>
<dl>
<dt><strong>public:</strong>
<dd><strong>static</strong> int <a href="prove.html#int_recursiveVerifier(int_depth,_const_domain&amp_x,const_domain&amp_z,_const_domain&amp_x0,const_domain&amp_z0,_const_taylorFunction*_I[],_int_count,const_cellOption&amp_options)$">recursiveVerifier</a>(int depth, const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z, const <a href="domain.html">domain</a>&amp x0,const <a href="domain.html">domain</a>&amp z0, const <a href="taylorFunction.html">taylorFunction</a>* I[], int count,const <a href="cellOption.html">cellOption</a>&amp options);
<dd><strong>static</strong> void <a href="prove.html#void_recursiveVerifierQ(int_depth,_const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,const_domain&amp_zB,_const_taylorFunction*_IA[],const_taylorFunction*_IB[],int_Nineq,_const_cellOption&amp_options)$">recursiveVerifierQ</a>(int depth, const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB, const <a href="domain.html">domain</a>&amp zA,const <a href="domain.html">domain</a>&amp zB, const <a href="taylorFunction.html">taylorFunction</a>* IA[],const <a href="taylorFunction.html">taylorFunction</a>* IB[],int Nineq, const <a href="cellOption.html">cellOption</a>&amp options);
<dd><strong>static</strong> int <a href="prove.html#int_generic(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_F)$">generic</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp F);
<dd><strong>static</strong> int <a href="prove.html#int_qrtet(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">qrtet</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_qrtetReduce_(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">qrtetReduce</a> (const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_flat(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flat</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_flatVc(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">flatVc</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_upright(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">upright</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_octa(const_domain&amp_x,const_domain&amp_z,const_taylorFunction&amp_FlessScore)$">octa</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z,const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_octaWithoutEta(const_domain&amp_x,const_domain&amp_z,_const_taylorFunction&amp_FlessScore)$">octaWithoutEta</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z, const <a href="taylorFunction.html">taylorFunction</a>&amp FlessScore);
<dd><strong>static</strong> int <a href="prove.html#int_quadcluster(const_domain&amp_xA,const_domain&amp_xB,_const_domain&amp_zA,_const_domain&amp_zB,_const_taylorFunction&amp_fA,_const_taylorFunction&amp_fB)$">quadcluster</a>(const <a href="domain.html">domain</a>&amp xA,const <a href="domain.html">domain</a>&amp xB, const <a href="domain.html">domain</a>&amp zA, const <a href="domain.html">domain</a>&amp zB, const <a href="taylorFunction.html">taylorFunction</a>&amp fA, const <a href="taylorFunction.html">taylorFunction</a>&amp fB);
<dt><strong>protected:</strong>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  prove<p>
<a name="parents"><hr><p></p></a>
<h2>Ancestors</h2>
Class does not inherit from any other class.<p>
<p>Back to the <a href="#topofdoc">top</a> of  prove<p>
<a name="children"><hr><p></p></a>
<h2>Descendants</h2>
Class is not inherited by any others.<p>
<p>Back to the <a href="#topofdoc">top</a> of  prove<p>
<hr><p></p>
Generated from source by the <i><a href="http://www.cs.umn.edu/~kotula/cocoon/cocoon.htm">Cocoon</a></i> utilities on Mon Dec 22 19:37:24 1997
.<p>
<address>Report <a href="mailto:jkotula@unimax.com">problems</a> to jkotula@unimax.com</address>
</body></html>
