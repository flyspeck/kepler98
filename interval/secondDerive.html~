<html><head><title>secondDerive Documentation</title></head>
<body><h1>
<a name="topofdoc"><img src="diag2min.gif">secondDerive</a></h1>
<dl>
<dd>
	Low level routines relating to the second derivative.  These
	should not generally be called directly by the end user.


	


</dl>
<hr><p></p>
<p><strong>[ 
<a href="kepler.html">kepler</a> | 
<a href="secondDerive.h">Source</a> | 
<a href="/keyweb.html">Keywords</a> | 
<a href="#aag">Summary</a> | <a href="#parents">Ancestors</a> | <a href="#flat">All Members</a> | <a href="#children">Descendants</a>  ]</strong><p>
<h2><a name="quickind">Quick Index</a></h2>
<dl>
<dd><a href="#OVERVIEW_TEXT">OVERVIEW TEXT</a>
<dd><a href="#AUTHOR">AUTHOR</a>
</dl>
<a name="aag"><hr><p></p></a><h2>Class Summary</h2>
class secondDerive<br>
<br>
 {
<br>
<br><i><b>public</b></i>:
<dl>
<dd><strong>static</strong> int <a href="secondDerive.html#int_setChi126(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setChi126</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setU126(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU126</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setU135(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU135</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDelta(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setDelta</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDihedral(const_double_x[6],const_double_z[6],double_DDf[6][6])$">setDihedral</a>(const double x[6],const double z[6],double DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDihedral(const_double_x[6],const_double_z[6],const_interval&amp_s,_const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDihedral</a>(const double x[6],const double z[6],const <a href="interval.html">interval</a>&amp s, const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDih2(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDih2</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDih3(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,_interval_Dh[6],interval_DDh[6][6])$">setDih3</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h, <a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setSolid(const_double_x[6],const_double_z[6],_const_interval_ss,const_interval_Ds[6],const_interval_DDs[6][6],_interval_DDx[6][6])$">setSolid</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a> ss,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a> DDx[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setSqrtDelta(const_double_x[6],const_double_z[6],_interval&amp_sqrt_d,interval_Dsqrt_d[6],interval_DDsqrt_d[6][6])$">setSqrtDelta</a>(const double x[6],const double z[6], <a href="interval.html">interval</a>&amp sqrt_d,<a href="interval.html">interval</a> Dsqrt_d[6],<a href="interval.html">interval</a> DDsqrt_d[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorAnalytic(const_double_x[6],const_double_z[6],_double_DD[6][6])$">setVorAnalytic</a>(const double x[6],const double z[6], double DD[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setChi2over4uDelta(const_double_x[6],const_double_z[6],double_DDf[6][6])$">setChi2over4uDelta</a>(const double x[6],const double z[6],double DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorVc(const_double_x[6],const_double_z[6],double_DD[6][6])$">setVorVc</a>(const double x[6],const double z[6],double DD[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorVcInverted(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorVcInverted</a>(const double x[6],const double z[6],double DDv[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorSqc(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorSqc</a>(const double x[6],const double z[6],double DDv[6][6]);
<dd><strong>static</strong> void <a href="secondDerive.html#void_selfTest()$">selfTest</a>();
</dl>
<i><b>protected</b></i>:
<dl>
</dl>
}; // secondDerive <p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>secondDerive</i><p>
<a name="OVERVIEW_TEXT"><hr><p></p></a><h3>OVERVIEW TEXT</h3>
<p>
	The class secondDerive contains a large number of static
	low level routines.  I do not see any reason that
	a user would want to call these routines directly.  They compute
	bounds on the second partial derivatives of various functions
	defined on a simplex.  This class is used by various
	Taylor approximation procedures to give rigorous upper and lower
	bounds on various functions.
<p>
	In the following routines x[] is the lower bound, 
	z[6] the upper on a cell.
	these are the edges squared, so that often they are in the range [4,8].
<p>
	Usually it is only the second deriviatives that are needed, but
	this usually requires computing the function value and the first
	derivatives as well, so often they are returned too.
<p>
<p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>secondDerive</i><p>
<a name="AUTHOR"><hr><p></p></a><h3>AUTHOR</h3>
<p>
	Thomas C. Hales
<p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>secondDerive</i><p>
<a name="int_setChi126(const_double_x[6],const_double_z[6],interval_DDf[6][6])$"><hr><p></p><h3>int setChi126(const double x[6],const double z[6],interval DDf[6][6]);</h3></a>
		   Give <a href="interval.html">interval</a> bounds on the second partial derivatives
		   of the function chi126. 
<p>
		   The input is the upper and lower bounds on the cell.
<p>
		   This procedure writes the partial derivatives to  DDf.
<p>
		   1 is the return value. Since chi126 is a polynomial, the 
		   computation will always be sucessful 
		   (unless outrageous arguments creating overflow are given). 
<p>
<p>
<p><pre>
static int <a href="#int_setChi126(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setChi126</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setU126(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$"><hr><p></p><h3>int setU126(const double x[6],const double z[6], interval DDf[6][6]);</h3></a>
		   Give <a href="interval.html">interval</a> bounds on the second partial derivatives
		   of the function u126. 
<p>
		   The input is the upper and lower bounds on the cell.
<p>
		   This procedure writes the partial derivatives to DDf.
<p>
		   1 is the return value.  Since u126 is a polynomial, the 
		   computation will always be sucessful 
		   (unless outrageous arguments creating overflow are given). 
<p>
<p>
<p><pre>
static int <a href="#int_setU126(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU126</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setU135(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$"><hr><p></p><h3>int setU135(const double x[6],const double z[6], interval DDf[6][6]);</h3></a>
		   Give <a href="interval.html">interval</a> bounds on the second partial derivatives
		   of the function u135. 
<p>
		   The input is the upper and lower bounds on the cell.
<p>
		   This procedure writes the partial derivatives to DDf.
<p>
		   1 is the return value.  Since u135 is a polynomial, the 
		   computation will always be sucessful. 
		   (unless outrageous arguments creating overflow are given). 
<p>
<p>
<p><pre>
static int <a href="#int_setU135(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU135</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setDelta(const_double_x[6],const_double_z[6],interval_DDf[6][6])$"><hr><p></p><h3>int setDelta(const double x[6],const double z[6],interval DDf[6][6]);</h3></a>
		   Give <a href="interval.html">interval</a> bounds on the second derivatives of the
		   function delta. 
<p>
		   The input is the upper and lower bounds on the cell.
<p>
		   This procedure writes the partial derivatives to DDf.
<p>
		   1 is the return value.  Since delta is a polynomial, the 
		   computation will always be sucessful.
		   (unless outrageous arguments creating overflow are given). 
<p>
<p>
<p><pre>
static int <a href="#int_setDelta(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setDelta</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setDihedral(const_double_x[6],const_double_z[6],double_DDf[6][6])$"><hr><p></p><h3>int setDihedral(const double x[6],const double z[6],double DDf[6][6]);</h3></a>
		   Give <a href="interval.html">interval</a> bounds on the function dih, and its
		   first and second partial derivatives.
<p>
		   The input is the upper and lower bounds on the cell.
<p>
		   This procedure writes the absolute value of the 
		   partial derivatives to DDf.
<p>
		   If the derivatives were
		   sucessfully computed a nonzero value is returned.
<p>
<p><pre>
static int <a href="#int_setDihedral(const_double_x[6],const_double_z[6],const_interval&amp_s,_const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDihedral</a>(const double x[6],const double z[6],double DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setDihedral(const_double_x[6],const_double_z[6],const_interval&amp_s,_const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$"><hr><p></p><h3>int setDihedral(const double x[6],const double z[6],const interval&amp s, const interval Ds[6],const interval DDs[6][6], interval&amp h,interval Dh[6],interval DDh[6][6]);</h3></a>
		   Compute the second derivative of the dihedral angle.
		   The dihedral angle is that along the first edge of the simplex.
		   All mixed partial derivatives are computed.
<p>
		   Input lower and upper bounds x,z on the lengths squared of
		   the edges.  The function also inputs sqrt(delta) 
		   and its first and second derivatives in
		   s, Ds, DDs.  The function returns a nonzero value if 
		   the calculation is a success.  The dihedral angle, and
		   its first and second derivatives are placed in h,Dh, and DDh.
<p>
<p><pre>
static int <a href="#int_setDihedral(const_double_x[6],const_double_z[6],const_interval&amp_s,_const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDihedral</a>(const double x[6],const double z[6],const <a href="interval.html">interval</a>&amp s,
	const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6],
	<a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setDih2(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$"><hr><p></p><h3>int setDih2(const double x[6],const double z[6], const interval&amp s,const interval Ds[6],const interval DDs[6][6], interval&amp h,interval Dh[6],interval DDh[6][6]);</h3></a>
		   Compute the second derivative of the dihedral2 angle.
		   The dihedral angle is that along the second edge of the simplex.
		   All mixed partial derivatives are computed.
<p>
		   Input lower and upper bounds x,z on the lengths squared of
		   the edges.  The function also inputs sqrt(delta) 
		   and its first and second derivatives in
		   s, Ds, DDs.  The function returns a nonzero value if 
		   the calculation is a success.  The dihedral angle, and
		   its first and second derivatives are placed in h,Dh, and DDh.
<p>
<p><pre>
static int <a href="#int_setDih2(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDih2</a>(const double x[6],const double z[6],
	const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6],
	<a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setDih3(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,_interval_Dh[6],interval_DDh[6][6])$"><hr><p></p><h3>int setDih3(const double x[6],const double z[6], const interval&amp s,const interval Ds[6],const interval DDs[6][6], interval&amp h, interval Dh[6],interval DDh[6][6]);</h3></a>
		   Compute the second derivative of the dihedral3 angle.
		   The dihedral angle is that along the third edge of the simplex.
		   All mixed partial derivatives are computed.
<p>
		   Input lower and upper bounds x,z on the lengths squared of
		   the edges.  The function also inputs sqrt(delta) 
		   and its first and second derivatives in
		   s, Ds, DDs.  The function returns a nonzero value if 
		   the calculation is a success.  The dihedral angle, and
		   its first and second derivatives are placed in h,Dh, and DDh.
<p>
<p><pre>
static int <a href="#int_setDih3(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,_interval_Dh[6],interval_DDh[6][6])$">setDih3</a>(const double x[6],const double z[6],
	const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6],
	<a href="interval.html">interval</a>&amp h, <a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setSolid(const_double_x[6],const_double_z[6],_const_interval_ss,const_interval_Ds[6],const_interval_DDs[6][6],_interval_DDx[6][6])$"><hr><p></p><h3>int setSolid(const double x[6],const double z[6], const interval ss,const interval Ds[6],const interval DDs[6][6], interval DDx[6][6]);</h3></a>
		   Compute <a href="interval.html">interval</a> bounds on the second derivative of the
		   solid angle of a simplex.  To call this procedure, it is
		   necessary first to have computed sqrt(delta) and its first
		   and second partials. 
<p>
		   Input x,z lower and upper bounds on the squares of the lengths
		   of the edges.
		   Input ss,Ds,DDs, the derivative information for sqrt(delta).
		   If the calculation is successful, a nonzero value is returned.
		   When the call is successful, 
		   the bounds on the second partials of the solid angle are
		   placed into the array DDx
<p>
<p><pre>
static int <a href="#int_setSolid(const_double_x[6],const_double_z[6],_const_interval_ss,const_interval_Ds[6],const_interval_DDs[6][6],_interval_DDx[6][6])$">setSolid</a>(const double x[6],const double z[6],
	const <a href="interval.html">interval</a> ss,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6],
	<a href="interval.html">interval</a> DDx[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setSqrtDelta(const_double_x[6],const_double_z[6],_interval&amp_sqrt_d,interval_Dsqrt_d[6],interval_DDsqrt_d[6][6])$"><hr><p></p><h3>int setSqrtDelta(const double x[6],const double z[6], interval&amp sqrt_d,interval Dsqrt_d[6],interval DDsqrt_d[6][6]);</h3></a>
		   Compute <a href="interval.html">interval</a> bounds on the value, derivatives, 
		   and second derivatives of
		   the function sqrt(delta).
		   The lower and upper values of the <a href="domain.html">domain</a> are passed in
		   the arrays x and z.  As usual, these represent the
		   lengths squared of the variables.
<p>
		   If the values are successfully computed a nonzero
		   value is returned, and the information is placed in
		   sqrt_d, Dsqrt_d, and DDsqrt_d.
<p>
		   If the return is 0, the values of sqrt_d, Dsqrt_d, and
		   DDsqrt_d is undefined.
<p>
<p><pre>
static int <a href="#int_setSqrtDelta(const_double_x[6],const_double_z[6],_interval&amp_sqrt_d,interval_Dsqrt_d[6],interval_DDsqrt_d[6][6])$">setSqrtDelta</a>(const double x[6],const double z[6],
	<a href="interval.html">interval</a>&amp sqrt_d,<a href="interval.html">interval</a> Dsqrt_d[6],<a href="interval.html">interval</a> DDsqrt_d[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setVorAnalytic(const_double_x[6],const_double_z[6],_double_DD[6][6])$"><hr><p></p><h3>int setVorAnalytic(const double x[6],const double z[6], double DD[6][6]);</h3></a>
		   Compute the <a href="interval.html">interval</a> bounds on the second derivatives of
		   the function vorAnalytic.
		   The lower and upper values of the <a href="domain.html">domain</a> are passes in
		   the arrays x and z.  As usual, these represent the 
		   lengths squared of the variables.
<p>
		   If the bounds are computed, the return value is nonzero,
		   and the bounds are returned in DD.  If the return value
		   is zero, the values of the array DD are undefined.
<p>
<p><pre>
static int <a href="#int_setVorAnalytic(const_double_x[6],const_double_z[6],_double_DD[6][6])$">setVorAnalytic</a>(const double x[6],const double z[6],
    double DD[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setChi2over4uDelta(const_double_x[6],const_double_z[6],double_DDf[6][6])$"><hr><p></p><h3>int setChi2over4uDelta(const double x[6],const double z[6],double DDf[6][6]);</h3></a>
		   chi^2/(4 u delta)+ eta^2 126 is the circumradius squared of a simplex.
		   Compute <a href="interval.html">interval</a> bounds on the second derivatives of
		   chi^2/(4 u delta).
		   The lower and upper values of the <a href="domain.html">domain</a> are passed in
		   the arrays x and z. As usual, these represent the lengths
		   squared of the variables.
<p>
		   If the values are successfully computed a nonzero
           value is returned, and the information is placed in DDf.
		   Otherwise the value of DDf is undefined.
<p>
<p><pre>
static int <a href="#int_setChi2over4uDelta(const_double_x[6],const_double_z[6],double_DDf[6][6])$">setChi2over4uDelta</a>(const double x[6],const double z[6],double DDf[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setVorVc(const_double_x[6],const_double_z[6],double_DD[6][6])$"><hr><p></p><h3>int setVorVc(const double x[6],const double z[6],double DD[6][6]);</h3></a>
		   Compute the <a href="interval.html">interval</a> bounds on the second derivatives of
           the function vorVc.
           The lower and upper values of the <a href="domain.html">domain</a> are passes in
           the arrays x and z.  As usual, these represent the
           lengths squared of the variables.
<p>
           If the bounds are computed, the return value is nonzero,
           and the bounds are returned in DD.  If the return value
           is zero, the values of the array DD are undefined.
<p>
<p><pre>
static int <a href="#int_setVorVc(const_double_x[6],const_double_z[6],double_DD[6][6])$">setVorVc</a>(const double x[6],const double z[6],double DD[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setVorVcInverted(const_double_x[6],const_double_z[6],double_DDv[6][6])$"><hr><p></p><h3>int setVorVcInverted(const double x[6],const double z[6],double DDv[6][6]);</h3></a>
           Compute the <a href="interval.html">interval</a> bounds on the second derivatives of
           the function vorVcInverted (used in octavor0).
           The lower and upper values of the <a href="domain.html">domain</a> are passes in
           the arrays x and z.  As usual, these represent the
           lengths squared of the variables.
<p>
           If the bounds are computed, the return value is nonzero,
           and the bounds are returned in DD.  If the return value
           is zero, the values of the array DD are undefined.
<p>
<p><pre>
static int <a href="#int_setVorVcInverted(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorVcInverted</a>(const double x[6],const double z[6],double DDv[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="int_setVorSqc(const_double_x[6],const_double_z[6],double_DDv[6][6])$"><hr><p></p><h3>int setVorSqc(const double x[6],const double z[6],double DDv[6][6]);</h3></a>
           Compute the <a href="interval.html">interval</a> bounds on the second derivatives of
           the function vorVcSqc, the truncation of voronoi at sqrt(2).
           The lower and upper values of the <a href="domain.html">domain</a> are passes in
           the arrays x and z.  As usual, these represent the
           lengths squared of the variables.
<p>
           If the bounds are computed, the return value is nonzero,
           and the bounds are returned in DD.  If the return value
           is zero, the values of the array DD are undefined.
<p>
<p><pre>
static int <a href="#int_setVorSqc(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorSqc</a>(const double x[6],const double z[6],double DDv[6][6]);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="void_selfTest()$"><hr><p></p><h3>void selfTest();</h3></a>
	   Check the correctness of secondDerive routines
<p>
<p><pre>
static void <a href="#void_selfTest()$">selfTest</a>();
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> secondDerive </i> <p>
<a name="flat"><hr><p></p></a>
<h2>All Members</h2>
<dl>
<dt><strong>public:</strong>
<dd><strong>static</strong> int <a href="secondDerive.html#int_setChi126(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setChi126</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setU126(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU126</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setU135(const_double_x[6],const_double_z[6],_interval_DDf[6][6])$">setU135</a>(const double x[6],const double z[6], <a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDelta(const_double_x[6],const_double_z[6],interval_DDf[6][6])$">setDelta</a>(const double x[6],const double z[6],<a href="interval.html">interval</a> DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDihedral(const_double_x[6],const_double_z[6],double_DDf[6][6])$">setDihedral</a>(const double x[6],const double z[6],double DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDihedral(const_double_x[6],const_double_z[6],const_interval&amp_s,_const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDihedral</a>(const double x[6],const double z[6],const <a href="interval.html">interval</a>&amp s, const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDih2(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,interval_Dh[6],interval_DDh[6][6])$">setDih2</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h,<a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setDih3(const_double_x[6],const_double_z[6],_const_interval&amp_s,const_interval_Ds[6],const_interval_DDs[6][6],_interval&amp_h,_interval_Dh[6],interval_DDh[6][6])$">setDih3</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a>&amp s,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a>&amp h, <a href="interval.html">interval</a> Dh[6],<a href="interval.html">interval</a> DDh[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setSolid(const_double_x[6],const_double_z[6],_const_interval_ss,const_interval_Ds[6],const_interval_DDs[6][6],_interval_DDx[6][6])$">setSolid</a>(const double x[6],const double z[6], const <a href="interval.html">interval</a> ss,const <a href="interval.html">interval</a> Ds[6],const <a href="interval.html">interval</a> DDs[6][6], <a href="interval.html">interval</a> DDx[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setSqrtDelta(const_double_x[6],const_double_z[6],_interval&amp_sqrt_d,interval_Dsqrt_d[6],interval_DDsqrt_d[6][6])$">setSqrtDelta</a>(const double x[6],const double z[6], <a href="interval.html">interval</a>&amp sqrt_d,<a href="interval.html">interval</a> Dsqrt_d[6],<a href="interval.html">interval</a> DDsqrt_d[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorAnalytic(const_double_x[6],const_double_z[6],_double_DD[6][6])$">setVorAnalytic</a>(const double x[6],const double z[6], double DD[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setChi2over4uDelta(const_double_x[6],const_double_z[6],double_DDf[6][6])$">setChi2over4uDelta</a>(const double x[6],const double z[6],double DDf[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorVc(const_double_x[6],const_double_z[6],double_DD[6][6])$">setVorVc</a>(const double x[6],const double z[6],double DD[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorVcInverted(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorVcInverted</a>(const double x[6],const double z[6],double DDv[6][6]);
<dd><strong>static</strong> int <a href="secondDerive.html#int_setVorSqc(const_double_x[6],const_double_z[6],double_DDv[6][6])$">setVorSqc</a>(const double x[6],const double z[6],double DDv[6][6]);
<dd><strong>static</strong> void <a href="secondDerive.html#void_selfTest()$">selfTest</a>();
<dt><strong>protected:</strong>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  secondDerive<p>
<a name="parents"><hr><p></p></a>
<h2>Ancestors</h2>
Class does not inherit from any other class.<p>
<p>Back to the <a href="#topofdoc">top</a> of  secondDerive<p>
<a name="children"><hr><p></p></a>
<h2>Descendants</h2>
Class is not inherited by any others.<p>
<p>Back to the <a href="#topofdoc">top</a> of  secondDerive<p>
<hr><p></p>
Generated from source by the <i><a href="http://www.cs.umn.edu/~kotula/cocoon/cocoon.htm">Cocoon</a></i> utilities on Mon Dec 22 19:37:25 1997
.<p>
<address>Report <a href="mailto:jkotula@unimax.com">problems</a> to jkotula@unimax.com</address>
</body></html>
